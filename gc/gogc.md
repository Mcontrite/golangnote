# 	Golang GC 知多少

在使用golang进行日常开发的时候一般不会关注gc性能，但如果出现内存泄露的话，不懂gc的话可能根本没有排查的头绪。因此去找些资料看了golang的gc策略，在这里简单做个总结归纳。

> 这里的版本是golang1.9+的策略，老版本的策略不再分析。

## 什么是垃圾回收

在偏硬件的编程语言里面(c/c++)，程序员都是直接管理内存的，在使用内存的时候需要程序员手动分配内存和释放内存，否则就容易发生内存泄露的问题。

管理内存给程序员带来了不少的心智负担，所以很多语言都内置了一套内存管理机制，程序员只需要关注内存申请即可，内存的释放交给语言层处理，这种回收不用的内存空间的技术就是垃圾回收机制。

## 垃圾回收算法

垃圾回收其实是一个很古老的话题了，经过多年的发展，产生了很多种垃圾回收的算法，其中最为基础的是`引用计数`，`标记清除`这两种，其他算法都是在这些基础上的优化。

### 引用计数

引用计数的策略非常简单，当一个对象被引用的时候，就将该对象的引用计数器加1，解除引用的时候就将计数器减1，当计数器为0的时候，就说明对象不被引用，这个对象再也不会被使用到了，在垃圾回收的时候就可以清理计数器为0的对象。

优点：算法简单，易于实现；渐进式gc，不同于其他算法在达到内存阈值的进行gc，引用计数可以分散在程序执行的各个阶段，不需要stw(stop the world)。

缺点：

1. 每次对象的引用和删除都需要变更计数器，频繁更新计数器会降低程序性能
2. 无法处理循环引用的问题，即使循环引用的两个对象都不被其他对象引用了，由于计数器不为0，对象空间还是不能被回收。

当然上面两个问题也并非无解，只是解决起来整个算法的复杂度会比较高。

### 标记清除

标记清除分为标记和清除两步，其中标记是从跟根结点出发遍历所有节点的引用对象，遍历结束之后就可以定位到不被引用的对象，也就是可回收的对象；清除就是清理可回收对象。标记清除算法有几个缺点：

1. 标记阶段需要STW：只有所有线程停止运行，保证内存中的对象引用关系不变，才可以得到准确的引用关系；
2. 产生内存碎片：可回收对象散布在内存各处，直接清理的话会产生很多内存碎片，影响大对象的分配。

### 并发标记清除

并发标记清除CMS(concurrency mark sweep)主要的优化目标是减少程序停顿(stw)的时间，将标记和清除这两个阶段都并发化提高效率，这里的并发指的是与用户程序一起并发。

首先被标记为可回收的对象都是程序中再也不会用到的对象，所以清除阶段的并发不会产生问题；但是标记阶段如果并发的话，用户程序可能会更改已标记的对象，或者产生新的对象，所以需要将并发阶段更新的对象记录下来。整体分为4个步骤：

1. 初始标记，这个阶段是标记根对象(全局对象和线程栈上的对象)。其中标记全局对象需要stw，标记线程栈只需要暂时目标线程即可。
2. 并发标记，这个阶段是并发遍历根对象的引用对象
3. 重新标记，这个阶段是重新标记在阶段2发生变更的对象，需要stw保证引用关系一致性
4. 并发清除

CMS虽然已经极大地减少了stw的时间，但是它还存在几个问题：

1. CMS使用并发的方式执行gc，会拉长整个gc的持续时间，另外gc期间会占用一定的cpu资源，导致响应变慢，吞吐量降低；
2. CMS是标注清除算法，一样会有内存碎片的产生。

### 标记整理

标记整理是对标记清除算法的改进，改善了内存碎片的状况，具体来说是将存活的对象往内存的一侧移动，保证内存的规整。

### 复制收集

复制收集也是对基础标记清除算法的一个改进，它是将内存一分为2，每次只使用一半的空间，gc的时候先标记对象，然后将存活的对象复制到另外一边，然后清理原空间即可。在复制的时候按照顺序分配的原则就可以保证没有内存碎片。这个算法的效率较高，但是缺点就是空了一半内存，内存使用率不高。

### 分代处理

分代处理不是垃圾回收算法，它是一种将对象按照存活时间分为新生代和老年代、并为不同分代采取不同gc算法的策略。按照局部性原理，程序中大量的对象存活时间都非常短，而存活时间较久的对象也将继续存活下去。因此新生代所需的空间相对较小，而老年代的空间较大。

根据这个特点，新生代一般采用复制收集算法，而老年代则搭配CMS算法。

## golang的gc

golang的gc使用了三色标记的CMS算法。gc的触发时机有3种：

1. 阈值：默认内存扩大一倍的时候触发一次gc
2. 定时：默认两分钟执行一次gc
3. 手动：手动调用runtime.GC()

三色标记指的是白灰黑三种颜色，含义如下：

- 白色：对象未标记
- 灰色：对象已经标记，但是子对象未标记
- 黑色：对象已经标记，且子对象也已经标记

三色标记的大概流程：

1. 所有对象最开始都是白色。
2. 从根节点遍历所有可触达的对象，标记为灰色，放入灰色队列中
3. 遍历灰色对象队列，将其引用对象标记为灰色，将自身标记为黑色
4. 继续遍历直达灰色对象队列为空，此时所有对象只有白色和黑色两种，完成标记

详细的过程如下图所示：

![img](https://pic4.zhimg.com/80/v2-16c97657566ff50944fed4658b7ac7c3_720w.jpg)

上图各步骤含义：

1. 从根节点开始遍历，根结点包括全局指针和goroutine栈上的指针；遍历全局指针需要stw，遍历goroutine栈时则只堵塞目标goroutine；在遍历goroutine stack的前需要stw打开写屏障。
2. 遍历灰色对象直到灰色对象队列为空，在此阶段中gc和用户程序是并发的，期间发生引用变更的对象都通过写屏障记录起来
3. 重新扫描阶段2记录下来的对象，为保持引用关系一致性，需要stw
4. 并发清除不可达对象(白色)，如果此次gc持续到下次gc开始，那么跟下次gc一期执行gc周期会有叠加的风险。

### 写屏障

因为并发标记过程中用户程序也在运行，期间会有新的对象产生、也会对已经标记的对象进行更改，打开了写屏障之后在发生对象内存修改的时候，会先判断对象的引用链，进行标注处理。在最新的runtime里面，采用了混合写屏障，已经可以去掉re-scan这一步了。

### STW

上文频繁提到stw(stop the world)，如何实现stw？

go的gmp模型里面，所有g都需要绑定到p上面才可以执行，而p存在空闲和运行中两种状态，那么第一步就是通知空闲状态的p不再接活。正在运行中的p里面可能有好几个g在运行，这时候就需要终止所有正在运行中的g。

这里需要注意的是，go的抢占式调度并非如操作系统那样可以直接换出线程，go实际上用的是伪抢占式：runtime给g设置抢占标志，g在发生系统调用、io操作、channel操作等一系列堵塞操作及函数调用的时候将自己的控制权让出来。

所以stw的实现归纳起来就是：

1. 设置空闲p的状态为停止；
2. 设置正在运行的g的抢占标志位，等待g主动停止运行，g的停止时机是发生系统调用、堵塞操作及函数调用。



# 图解Golang的GC算法

虽然Golang的GC自打一开始，就被人所诟病，但是经过这么多年的发展，Golang的GC已经改善了非常多，变得非常优秀了。

以下是Golang GC算法的里程碑：

- v1.1 STW
- v1.3 Mark STW, Sweep 并行
- v1.5 三色标记法
- v1.8 hybrid write barrier

经典的GC算法有三种： `引用计数(reference counting)`、 `标记-清扫(mark&sweep)`、 `复制收集(CopyandCollection)`。

Golang的GC算法主要是基于 `标记-清扫(markandsweep)`算法，并在此基础上做了改进。

## 标记-清扫(Mark And Sweep)算法

此算法主要有两个主要的步骤：

- 标记(Mark phase)
- 清除(Sweep phase)

第一步，找出不可达的对象，然后做上标记。 第二步，回收标记好的对象。

操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 `stop the world`。 也就是说，这段时间程序会卡在哪儿。故中文翻译成 `卡顿`。

我们来看一下图解：

开始标记，程序暂停。程序和对象的此时关系是这样的：

![img](https://static.studygolang.com/190312/fad196e90b3a01009a910430204e5eee.png)

然后开始标记，process找出它所有可达的对象，并做上标记。如下图所示：

![img](https://static.studygolang.com/190312/9403f17a490cafff06ade7ddddb31d5e.png)

标记完了之后，然后开始清除未标记的对象：

![img](https://static.studygolang.com/190312/a5e0e7207e53339f88a3d9e5776711f1.png)

然后垃圾清除了，变成了下图这样。

![img](https://static.studygolang.com/190312/942e326db4c380a421f53284f0b82e26.png)

最后，停止暂停，让程序继续跑。然后循环重复这个过程，直到process生命周期结束。

### 标记-清扫(Mark And Sweep)算法存在什么问题？

标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：

- STW，stop the world；让程序暂停，程序出现卡顿。
- 标记需要扫描整个heap
- 清除数据会产生heap碎片

这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。

Go是如何面对并这个问题的呢？

## 三色并发标记法

我们先来看看Golang的三色标记法的大体流程。

首先：程序创建的对象都标记为白色。

![img](https://static.studygolang.com/190312/ee13e4c6b51d476066656511e0b52793.png)

gc开始：扫描所有可到达的对象，标记为灰色

![img](https://static.studygolang.com/190312/bb38c7cc70248a7e62d3ee7c9e3004ca.jpg)

从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色

![img](https://static.studygolang.com/190312/9112b0dc5b1e88e3734bc9b75774811c.jpg)

监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在

![img](https://static.studygolang.com/190312/7f876d8312420ab12b815a0657e926b2.jpg)

此时，gc回收白色对象。

![img](https://static.studygolang.com/190312/bc5066ca0ed6217a04b8cf5f46fb15fa.jpg)

最后，将所有黑色对象变为白色，并重复以上所有过程。

![img](https://static.studygolang.com/190312/0168804c179a842c48b5b421156c0e0d.png)

好了，大体的流程就是这样的，让我们回到刚才的问题：Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？

## gc和用户逻辑如何并行操作？

标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

Go如何减短这个过程呢？三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑，所以清除操作和用户逻辑可以并发。

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？

## process新生成对象的时候GC该如何操作？

我们看如下图，在此状态下：process程序又新生成了一个对象，我们设想会变成这样：

![img](https://static.studygolang.com/190312/d8e45b3b7253575e984d053775a58133.jpg)

但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。

Golang为了解决这个问题，引入了 写屏障这个机制。 写屏障在gc运行的过程中可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)

在上述情况中， 新生成的对象，一律都标位灰色！即下图：

![img](https://static.studygolang.com/190312/861fa4cc3592f17c8ed272928c3b2a9e.jpg)

## 灰色或者黑色对象的引用改为白色时该如何操作？

看如下图，一个黑色对象引用了曾经标记的白色对象。

![img](https://static.studygolang.com/190312/b47146afaae8ebdc4e6fb89cba56781d.jpg)

这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。

![img](https://static.studygolang.com/190312/5b992e40caedea487961adc1d0a7a564.jpg)

因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。



# golang垃圾回收

## GC性能的评价标准

- 吞吐量：是指单位时间内是有多少时间是用来运行user application的。GC占用的时间过多，就会导致吞吐量较低。
- 最大暂停时间：基本上所有的垃圾回收算法，都会在执行GC的过程中，暂停user application。如果暂停时间过长，必然会影响用户体验，尤其是那些交互性较强的应用。
- 堆对象头部大小：一般来说堆的头部越大，存储的信息越多，那么GC的效率就会越高，吞吐量也会有更佳的表现。但是对象头必须尽量越小越好。
- 堆的使用方法：对于堆的不同用法也会导致堆使用效率差距非常大。比如复制算法，用户应用只能使用一半的堆大小，如果因为GC导致过量占用堆，那么就是本末倒置了。
- 访问的局部性：具有引用关系的对象之间很可能存在连续访问的情况。因此把具有引用关系的对象安排在堆中较近的位置，可以充分利用内存访问局部性。有的GC算法会根据引用关系重排对象，比如复制算法。

设计垃圾回收算法时，折中无处不在，较大的吞吐量和较短的最大暂停时间往往不可兼得。

## 写屏障

golang采用三色法作为`GC`的计算方式， 对于已经扫描过的对象， 如何检测是否由于用户逻辑的变化而引起了数据变化呢？

golang中采用了写屏障的方式， 对扫描过后的对象使⽤操作系统写屏障功能⽤来监控⽤户逻辑这段内存。任何时候这段内存发⽣引⽤改变的时候就会造成写屏障发⽣⼀个信号，垃圾回收器会捕获到这样的信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否被改变，这样利⽤状态的重置从⽽实现当对象状态发⽣改变的时候依然可以判断它是活着的还是死的。

## GC的时间

**GC触发时机**

GC触发的时机：2分钟或者内存占用达到一个阈值（当前堆内存占用是上次gc后对内存占用的两倍，当GOGC=100时）

**GC的总时间**

`Tgc = Tseq + Tmark + Tsweep`(T表示time)

- `Tseq`表示是停止用户的`goroutine`和做一些准备活动（通常很小）需要的时间
- `Tmark`是堆标记时间，标记发生在所有用户`goroutine`停止时，因此可以显著地影响处理的延迟
- `Tsweep`是堆清除时间，清除通常与正常的程序运行同时发生，所以对延迟来说是不太关键的

**STW的时机**

1.`goroutine`被停止后， `GC`将要开始的是时候会做一些准备工作，如写屏障设置等会执行STW

2.`re-scan`的时候执行STW，停止用户程序，检验已经扫描的元素是否发生引用的变化

## 提高GC的性能

当前GC的算法是固定的， 用户不能够配置垃圾回收的算法，唯一能够更改就是垃圾回收的阀值， 即`GOGC`， 用来表示触发GC的条件。

当前能够提升垃圾回收效率的唯一方式就是**减少垃圾**的产生，可通过下面的方式

- `内存分配合理`
- `sync.Pool`对象池，重复使用对象， 减少内存分配
- `append`使用， 提前设置`cap`的数量， 避免无故扩容

### 减少创建临时堆对象

尽量避免频繁创建临时堆对象（如&abc{}， new, make等）以减少垃圾收集时的扫描时间，对于需要频繁使用的临时对象考虑直接通过数组缓存进行重用

### 少量使用+连接string

`+`进行string的连接会生成新的对象，降低gc的效率，好的方式是通过append函数来进行。

### 减少string与[]byte转化

在stirng与[]byte之间进行转换，会给gc造成压力 通过gdb，可以先对比下两者的数据结构：

```go
type = struct []uint8 { 
    uint8 *array; 
    int len;
    int cap;
}

type = struct string { 
    uint8*str; 
    int len;
}
```

两者发生转换的时候，底层数据结结构会进行复制，因此导致gc效率会变低。解决策略：

1. 一直使用[]byte，特别是在数据传输方面，[]byte中也包含着许多string会常用到的有效的操作。
2. 使用更为底层的操作直接进行转化，避免复制行为的发生。主要是使用unsafe.Pointer直接进行转化。

## goroutine泄露

如果一个服务需要处理很多长连接请求，实现时对于每个长连接请求各开了一个读取和写入协程，全部采用endless for loop不停地处理收发数据。当连接被远端关闭后，如果不对这两个协程做处理，他们依然会一直运行，并且占用的channel也不会被释放…

这里就必须十分注意，在不使用协程后一定要把他依赖的channel close并通过再协程中判断channel是否关闭以保证其退出。

## 停止大量请求后内存使用量并没有立即降下来

1. go的垃圾回收有个触发阈值，这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是10MB则下一次就是20MB，再下一次就成为了40MB…），如果长时间没有触发gc go会主动触发一次（2min）。高峰时内存使用量上去后，除非持续申请内存，靠阈值触发gc已经基本不可能，而是要等最多2min主动gc开始才能触发gc。

2. go语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；操作系统会采取“拖延症”策略，并不是立即回收，而是等到系统内存紧张时才会开始回收，这样该程序又重新申请内存时就可以获得极快的分配速度。
