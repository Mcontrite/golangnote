# 进程、线程、协程、goroutine区别

## **概念理解**

**1、进程**

进程是系统进行资源分配和调度的一个独立单位，每个有自己的独立内存空间和堆栈，进程之间互相隔离。由操作系统调度，既不共享堆，亦不共享栈，不同进程通过进程间通信来通信。进程间的切换上下文开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

**2、线程**

线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。由操作系统调度，不拥有系统资源，与同属一个进程的其他的线程共享进程的全部资源，拥有自己独立的栈、寄存器和共享的堆；共享堆，不共享栈。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定，容易丢失数据。

**3、协程**

协程是在应用层模拟的线程，避免了上下文切换的额外耗费，是一种用户态的轻量级线程(内存2kb ：8mb，寄存器3 ：16)，调度完全由用户控制。和线程一样共享堆，不共享栈，拥有自己的寄存器上下文和栈。 

## 关系

进程、线程、协程的关系和区别：

- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
- 协程和线程一样共享堆，不共享栈，协程由程序开发者在协程的代码里显示调度。

## 区分

 一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。

**进程、线程 和 协程 之间概念的区别**

进程**、**线程都是有内核进行调度，有 CPU 时间片的概念，进行 **抢占式调度**。协程由用户程序自己控制，很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 **协作式调度**，需要协程自己主动把控制权转让出去之后，其他协程才能被执行，不能在一个协程中杀死另外一个协程。

**goroutine 和协程区别**

本质上 goroutine 就是协程，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，方便调度和执行，也就是 Golang 从语言层面支持了协程。

## Goroutine和线程的区别

### 调度开销更小

OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。

Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。

### 栈空间更动态灵活

每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。

### goroutine没有特定的标识

在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。

goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。

## 为什么协程比线程轻量？

1. go协程调用跟切换比线程效率高，切换发生在用户态，没有时钟中断，系统调用等机制，因此效率高

2. 执行go协程只需要极少的栈内存（大概是4～5KB），可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行。

## 协程与Goruntine

1. 协程是Coroutine，Go语言的协程是Goruntine。
2. Go 协程通过通道来通信，而协程通过让出和恢复操作来通信。
3. goroutine 有自己的调度器，**工作方式基本上是协作式，而不是抢占式**，但也不是完全的协作式调度，例如在系统调用的函数入口处会有抢占。

## goroutine协程

线程切换需要陷入内核，然后进行上下文切换，而协程在用户态由协程调度器完成，不需要陷入内核，这代价就小了；另外，协程的切换时间点是由调度器决定的，而不是系统内核决定的，尽管他们切换点都是时间片超过一定阈值，或者进入I/O或睡眠等状态；再次，还有垃圾回收的考虑，因为go实现了垃圾回收，而垃圾回收的必要条件时内存位于一致状态，这就需要暂停所有的线程，如果交给系统去做，那么会暂停所有的线程使其一致，而在go里面调度器知道什么时候内存位于一致状态，那么就没有必要暂停所有运行的协程。

go调度里面有三个角色：三角形M代表内核线程，正方形P代表上下文，圆形G代表协程: ![goroutine1](http://vinllen.com/content/images/2018/goroutine/goroutine1.jpg)
下面图我们看到他们之间的对应规则：一个M对应一个P，一个P下面挂多个G，但一个时候只有一个G在跑，其余都是放入等待队列，等待下一次切换时使用。
![goroutine2](http://vinllen.com/content/images/2018/goroutine/goroutine2.jpg)
假如一个运行的协程G调用syscall进入阻塞怎么办？如下图左边，G0进入阻塞，那么P会转移到另外一个内核线程M1（此时还是1对1）。当syscall返回后，需要抢占一个P继续执行，如果抢占不到，G0挂入全局就绪队列runqueue，等待下次调度，理论上会被挂入到一个具体P下面的就绪队列runqueu（区别于全局runqueue）。
![goroutine3](http://vinllen.com/content/images/2018/goroutine/goroutine3.jpg)
一个P0下面的所有G都跑完了，怎么办？这时候会从别的P1下面就绪队列抢占G进行运行，个数为P1就绪队列的一半。
![goroutine4](http://vinllen.com/content/images/2018/goroutine/goroutine4.jpg)

# GPM 简单理解

一，GPM各个的意思和作用

- G: 表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。
- P: 表示逻辑processor，P的数量决定了系统内最大可并行的G的数量（前提：系统的物理cpu核数>=P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。
- M: M代表着真正的执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。

二、GPM之间的配合作用

1）G的出现

新创建一个goroutine（G）时会，检查是否有闲置的p（p的数量是根据cpu中的线程决定的，比如双核四线程，就可以认为是p最大数量可以为4），若有,则将G添加到已经绑定好的P和M中的P的G队列中，等待被调度。

- 问题1，P和M是如何绑定的
- 问题2，如果没有了闲置的P,那么G放入到哪个P的队列中

2）G的调度其实是一种抢占式的调度。（饥饿游戏-抢）

当程序启动后，会存在一个sysmon线程（监控线程），属于制定规矩的超级管理者，它会一直存在而且不会受控于GPM规则。当它检查所有的G时，发现某个G运行时间已经很长了（time=10ms）,那么sysmon就对该G进行留校察看处分将其标志位置为true,表示该G在下次调用函数时就会被其他的G(已经在队列中等了很久了)抢占，让出对应的M供新的G进行调用

- 问题1，被抢占的G是否是又被重新放到其所在的队列中

3）GPM之间的关系图

![img](https://img2020.cnblogs.com/blog/1426761/202003/1426761-20200320103544032-581549103.png)

# Golang 协程调度

### 一、线程模型

- N:1模型，N个用户空间线程在1个内核空间线程上运行。优势是上下文切换非常快但是无法利用多核系统的优点。
- 1:1模型，1个内核空间线程运行一个用户空间线程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。（POSIX线程模型(pthread)，Java）
- M:N模型， 每个用户线程对应多个内核空间线程，同时也可以一个内核空间线程对应多个用户空间线程。Go打算采用这种模型，使用任意个内核模型管理任意个goroutine。这样结合了以上两种模型的优点，但缺点就是调度的复杂性。

下面看看golang的协程调度

- M：一个用户空间线程，同时对应一个内核线程，类似posix pthread
- P：代表运行的上下文环境, 也就是我们上一节实现的调度器，一个调度器也会对应一个就绪队列
- G：goroutine，即协程

### 二、调度模型简介

groutine能拥有强大的并发实现是通过GPM调度模型实现，下面就来解释下goroutine的调度模型。

![img](https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704144900055-654632620.jpg)

Go的调度器内部有三个重要的结构：M，P，G

- M：M是对内核级线程的封装，数量对应真实的CPU数，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
- P：P全称是Processor，处理器，它的主要用途就是用来执行goroutine的。每个Processor对象都拥有一个LRQ（Local Run Queue），未分配的Goroutine对象保存在GRQ（Global Run Queue ）中，等待分配给某一个P的LRQ中，每个LRQ里面包含若干个用户创建的Goroutine对象。
- G：代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。

Golang采用的是多线程模型，更详细的说他是一个两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。

#### 调度实现

![img](https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704160300058-287296807.jpg)

从上图中看，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。
P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。
图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），
Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个
goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。

 

当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。

![img](https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704162532330-809705926.jpg)

 



当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，
如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。

 

另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的使用，如下图：

![img](https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180704164251684-1689850867.jpg)

### 三、GPM创建相关问题

#### M和P的数量如何确定？或者说何时会创建M和P？

1、P的数量：

- 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定（默认是1）。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。

2、M的数量:

- go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug中的SetMaxThreads函数，设置M的最大数量
- 一个M阻塞了，会创建新的M。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

3、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

4、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

#### M选择哪一个P关联？

- M会选择导致此M被创建的那个P关联。

#### 什么时候会切换P与M的关联关系？

当M因系统调用而阻塞时（M上运行的G进入了系统调用的时候），M与P会分开，如果此时P的就绪队列中还有任务，
P就会去关联一个空闲的M，或者创建一个M进行关联。（也就是说go不是像libtask一样处理IO阻塞的？不确定。）

#### 就绪的G如何选择进入哪个P的就绪队列？

- 默认情况下：因为P的默认数量是1（M不一定是1），所以如果我们不改变GOMAXPROCS，无论我们在程序中用go语句创建多少个goroutine，它们都只会被塞入同一个P的就绪队列中。
- 有多个P的情况下：如果修改了GOMAXPROCS或者调用了runtime.GOMAXPROCS，运行时系统会把所有的G均匀的分布在各个P的就绪队列中。

#### 如何保证每个P的就绪队列中都会有G

如果一个P的就绪队列所有任务都执行完了，那么P会尝试从其他P的就绪队列中取出一部分到自己的就绪队列中，以保证每个P的就绪队列都有任务可以执行。